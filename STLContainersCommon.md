## Common Capabilities ##

  * 容器内的元素必须要\_拷贝\_到容器内部，而不是提供reference。即：容器内元素必须是可以\_复制\_的，如果对象不能复制，那么拷贝指向对象的指针到容器里；

  * 容器内的对象必须是有序的，迭代器按照固定的次序可以遍历到相同的对象；

  * 容器的方法不检查参数的正确性，正确性由调用者保证，传递不正确的参数会导致Undefined Behavior；

## Common Operations ##

### 初始化 ###

所有的容器都提供一个默认构造函数，一个拷贝构造函数和一个析构函数。容器的构造函数可以用三种方法初始化一个容器：

**通过另一个容器：
```
std::list<int> l;
std::vector<float> c(l.begin(), l.end());
```**

**通过数组：
```
int array[] = { 2, 3, 17, 33, 45, 77 };
std::set<int> c(array, array + sizeof(array)/sizeof(array[0]));
```**

**通过标准输入：
```
std::deque<int> c((std::istream_iterator<int> (std::cin)), 
                  (std::istream_iterator<int>()));
```**

注意`std::istream_iterator<int>()`外面的括号不能少，否则c会被认为是一个函数声明。

| **Operation** | **Effect** |
|:--------------|:-----------|
| `ContType c`  | 创建一个空容器c   |
| `ContType c2(c1)`| 复制容器c1     |
| `ContType c(beg, end)` | 用迭代器指向的[beg, end)范围内的元素初始化容器 |
| `c.~ContType()` | 删除容器内所有对象并释放内存 |

### 尺寸相关 ###

所有的容器都提供了三个和“尺寸”相关的方法：

| **Operation** | **Effect** |
|:--------------|:-----------|
| `size()`      | 返回容器内元素的数量 |
| `empty()`     | 虽然是size() == 0的等价物，但是可能会更高效，总之用这个判断容器是否为空就对了|
| `max_size()`  | 返回容器内可以保存的最大元素数量，这个值和具体的容器类型的实现相关，例如vector，和系统的可用内存相关，其他的容器，有可能和容器索引的类型有关。 |

### 比较操作 ###

所有的容器都支持==, !=, <, <=, >, >=比较操作。比较时，应遵循以下原则：

  * 进行比较的容器的类型必须相同；
  * 两个容器如果元素数量相等，并且每一个元素的位置和值都相同，则两个容器相等；
  * 容器的小于比较操作使用字典比较法进行判定；

如果想比较不同类型的容器，要使用STL的算法。

### 赋值和swap() ###

对一个容器赋值，则目标容器原来的元素都将被删除，然后源容器的所有元素都拷贝到目标容器内。如果源容器不再使用，使用swap()进行是一个更高效的“赋值”方法，通常，它只更改目标容器内的一些指针。